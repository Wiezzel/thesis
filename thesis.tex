\documentclass{pracamgr}

\usepackage{polski}
\usepackage[utf8]{inputenc}
\usepackage[backend=biber,style=numeric]{biblatex}
\usepackage{changepage}

\author{Adam Wierzbicki}
\nralbumu{306441}
\title{Using Code History for Defect Prediction}
\tytulpl{Wykorzystanie historii kodu do predykcji błedów}
\kierunek{Informatyka}
\opiekun{
	dr. hab. Krzysztofa Stencla, prof. UW\\
	Instytut Informatyki
}
\date{Marzec 2015}
\dziedzina{11.3 Informatyka}
\klasyfikacja{
	D. Software\\
	D.2. Software Engineering\\
	D.2.8 Metrics\\
	D.2.9 Management
}
\keywords{code history, defect, bug-proneness, prediction, repository, metrics, machine learning}

\bibliography{bibliography}

\renewcommand{\contentsname}{Table of Contents}
\renewcommand{\chaptername}{Chapter}

\begin{document}

\maketitle

\begin{abstract}
Detection of software defects has become one of the major challenges in the field of automated software engineering. Numerous studies have revealed that mining data from repositories could provide a substantial basis for defect prediction. In this thesis I introduce my approach towards this problem relying on the analysis of source code history and machine learning algorithms. I describe in detail the proposed computational procedures and explain their underlying assumptions. Following the theoretical basis, I  present the results of performed experiments which serve as an empirical assessment of the effectiveness of my methods.
\end{abstract}

\tableofcontents

\chapter{Introduction}
\label{cha:introduction}
Ever since the legendary first bug in 1947\footnote{According to \cite{first_bug} on 9th of September, 1947 an investigation of malfunctioning Harvard University Mark II Aiken Relay Calculator revealed a moth trapped between the points of relay \#70 in panel F. This event was reported in a log with the following statement: \textit{"First actual case of bug being found."}}, the detection of software faults has been a crucial part of the quality assurance process. Undiscovered bugs were the cause of many misfortunes with the crash of the \$500-million space rocket Ariane 5 being the most spectacular example.\footnote{On 4th of June, 1996 the rocket was launched by the European Space Agency from Kourou in French Guyana. It exploded only about 40 seconds after take-off due an error in the inertial reference system -- conversion of a 64-bit float to a 16-bit signed integer failed, because the number was larger than the largest storable value. \cite{ariane}} This work aims to contribute to the general improvement of software quality by investigating certain methods of error identification.

\section{Topic choice rationale}
\label{sec:topic_choice}
Various procedures have been applied to track down software defects before they would cause any problems. Most widely used techniques are testing and code reviewing. Both of them are quite successful, but unfortunately also very arduous. In order to improve the performance of these methods and reduce the programmers' effort needed to conduct them, automatic debugging programs are developed.

Such programs include a broad range of approaches towards detecting bugs. Some of them are run-time debuggers which help programmers analyse the execution of a program (either standalone as GDB \cite{gdb} or integrated with IDEs as Microsoft Visual Studio Debugger \cite{vs_debugger}). Others generate test cases using randomization and symbolic execution \cite{symbolic, puzzle}. Others support the reviewing process by highlighting potentially dangerous program parts.

Identification of such fault-prone elements could be performed using many different methods. There are tools which rely on hard-coded patterns of so-called ``bad code smells" (e.g. FindBugs \cite{findbugs}). Other ones incorporate statistical analysis and machine learning, using various software metrics and properties (e.g. HATARI \cite{hatari}). In this work I focus on the latter approach, because I find it more interesting and less frequently encountered. I decided to use historical metrics\footnote{Software metrics based on change history, called also \emph{repository metrics} or \emph{process metrics}.} which have proven to be well-suited for this task \cite{merits, comparative, how_and_why}. With my research I hope to extend the knowledge about methods of bug prediction, which is not only of theoretical but also of practical value. This thesis makes the following contributions:
\begin{itemize}
	\item Proposal of a novel method for bug prediction,
	\item Prototype implementation of the proposed method,
	\item Experimental evaluation of the implemented tool.
\end{itemize}

\section{Document structure}
\label{sec:structure}

\textbf{Chapter \ref{cha:introduction}} includes general introductory information for the thesis, topic choice rationale, and a sketch of the document structure. 

\medskip \noindent
\textbf{Chapter \ref{cha:overview}} contains a broad and comprehensive description of the problem of bug prediction. I try to define in a possibly precise manner all terms relevant to this topic. Then I present the general goals of the prediction process and its consecutive phases. I describe several kinds of sub-problems which have to be solved in order to successfully develop an error detection instrument.

\medskip \noindent
\textbf{Chapter \ref{cha:approach}} presents my approach towards the problem. The proposed method is based on extraction of historical information from a version control system and application of a machine learning algorithm. I describe the general model of a changing method\footnote{In the object-oriented-programming sense}, which is the principal element of the whole procedure, as well as successive phases such as feature extraction, identification of bug-fixes, assignment of bug-proneness scores and training a regressor. In the last section of this chapter, I list four different machine learning algorithms which are evaluated in chapter \ref{cha:experiments}.

\medskip \noindent
\textbf{Chapter \ref{cha:implementation}} describes the ChangeAnalyzer tool -- an implementation of the approach proposed in chapter \ref{cha:approach}. I present all used technologies (languages and libraries), software architecture and the interface.

\medskip \noindent
\textbf{Chapter \ref{cha:experiments}} contains a description of experiments which were performed to evaluate the proposed approach and compare the performance of different algorithms listed in section \ref{sec:machine_learning}. I explain the methodology of these experiments and software configuration necessary to conduct them. Then I give an overview of the experimental data and finally present the results in form of tables and plots.

\medskip \noindent
\textbf{Chapter \ref{cha:conclusions}} includes a commentary of the experimental results and possible threats to the validity of my research. After these, I try to fairly asses in general my approach towards the problem of bug prediction. In the last section I propose possible ways of continuation of my work on this topic.

\chapter{Problem overview}
\label{cha:overview}

\section{Terminology}
\label{sec:terminology}
Before referring the topic, I would like to define some concepts of major importance, namely: \emph{version control system}, \emph{software repository}, \emph{commit}, and \emph{bug-fix}. Below are given brief explications of how I understand these terms.

\bigskip \noindent
\textbf{Version control system}
\begin{adjustwidth}{\parindent}{}
``A system capable of recording the changes made to a file or a set of files over a time period in such a way that it allows us to get back in time from the future to recall a specific version of that file" \cite[p. 8]{git_book}. Usually, such system is used to manage the source code of a software project. Examples of VCSs are: Apache\textsuperscript{TM} Subversion\textsuperscript{\textregistered} \cite{subversion}, Git \cite{git}, or Mercurial \cite{mercurial}.
\end{adjustwidth}

\medskip \noindent
\textbf{Software repository}
\begin{adjustwidth}{\parindent}{}
A directory containing the source code of a software project, which is managed by a version control system. It could be either local or remote (accessed via HTTPS or SSH protocol).
\end{adjustwidth}

\medskip \noindent
\textbf{Commit}
\begin{adjustwidth}{\parindent}{}
``An atomic collection of changes to files in a repository. It contains all recorded local modifications that lead to a new revision of the repository" \cite{mercurial_wiki}. Apart from file changes, a commit contains meta-information such as: committer's name and e-mail address, date and time, and a description of changes. Commit is also often called \emph{changeset}.
\end{adjustwidth}

\medskip \noindent
\textbf{Error}
\begin{adjustwidth}{\parindent}{}
``An incorrect step, process, or data definition. For example, an incorrect instruction in a computer program." \cite[p. 31]{glossary}. Error is also called \emph{bug}, \emph{fault}, or \textit{defect}.
\end{adjustwidth}

\medskip \noindent
\textbf{Bug-fix}
\begin{adjustwidth}{\parindent}{}
A commit created in order to repair a software defect. It is usually distinguished by an appropriate commit message describing the fixed error.
\end{adjustwidth}

\medskip \noindent
\textbf{Error prediction}
\begin{adjustwidth}{\parindent}{}
According to \cite[p. 31]{glossary}, it is ``a quantitative statement about the expected number or nature of faults in a system or component." We will extend this definition to mean the whole procedure that leads to issuing such statement.
\end{adjustwidth}

\medskip \noindent
\textbf{Error model}
\begin{adjustwidth}{\parindent}{}
``In software evaluation, a model used to estimate or predict the number of remaining faults, required test time, and similar characteristics of a system" \cite[p. 31]{glossary}.
\end{adjustwidth}

\section{Goals and sub-problems}
\label{sec:goals_and_subproblems}
Simply speaking, bug prediction is a procedure aimed at automatic detection of faults in an unreviewed and untested code, basing on reports about previously discovered bugs. However, this deceptively plain definition hides a very convoluted and problematical process. In this section I would like to explore its meanders and formulate a more precise description by answering questions such as: \emph{\textbf{What is it} exactly that we are predicting?} (\ref{sec:dependent_variable}) \emph{What is \textbf{the scope} of our prediction?} (\ref{sec:unit_of_analysis}) \emph{How do we learn about \textbf{former defects}?} (\ref{sec:identification}) and \textit{What \emph{kinds of information} can we utilize in our prediction?} (\ref{sec:observable_variables})

\subsection{Dependent variable}
\label{sec:dependent_variable}
Prediction in general may be described as discovering a relation between several observable variables and a dependent variable (which may also be called \textit{target variable}). The discovered relation allows for estimating values of the target variable by analysing the observables. Trying to conform \textit{defect prediction} to this description seems problematic, because ``defect" doesn't name any well-defined variable. Therefore, the first fundamental concern of bug prediction is specifying a variable which will both suit our theoretical framework and embrace the common-sense intuitions.

The most obvious candidate (used e.g. by Janes \textit{et al.} in \cite{Janes}) is the number of defects per software unit (for possible units see \ref{sec:unit_of_analysis}). However, as in many cases the numbers of bugs in software components are relatively small, a dichotomous boolean variable (indicating bug presence or absence) is used more often (e.g. by Moser \textit{et al.} in \cite{comparative} or Giger \textit{et al.} in \cite{method-level}). More complex examples include \emph{fault density} -- number of faults divided by a code size measure (Tomaszewski \textit{et al.} \cite{Tomaszewski}), or expected number of repairs in some period of time (Hassan~\textit{et~al.}~\cite{complexity}).

As \cite[p. 5]{systematic} reasonably states, the choice of dependent variable should be determined by the further usage of the developed model. For assigning a software component for a detailed examination by a reviewer, a boolean variable is probably sufficient. On the other hand, creating a ranking or visualisation of the software quality requires numeric values, so number of defects or fault density would suit these purposes much better.

\subsection{Unit of analysis}
\label{sec:unit_of_analysis}
All of the variables defined in the above section are relative to some code segment. Size of such segment can span from a single function up to a whole project -- every possibility has its advantages and drawbacks. As nine of ten most popular programming languages are object-oriented \cite{popularity1,popularity2}, also the most commonly encountered units of analysis are related to OOP paradigm: module/package, class, or method/function. 

Package-level prediction (used e.g. by Jin \textit{et al.} in \cite{Jin}) can make use of structural software properties which cannot be computed for smaller units. However, the typical size of a package in some languages would make the corresponding fault-proneness value of very little value for practical application. Therefore, module- or package-level prediction is usually restricted to languages to which the class level does not apply, e.g. Fortran, Pascal or Ada. 

Class level (used e.g. by Tomaszewski \textit{et al.} in \cite{Tomaszewski}) is the most popular choice among defect prediction studies. Probably, the reason for this popularity is the fact that class is the most natural and accustomed part of an object-oriented software. In case of non-object-oriented languages, the middle-sized unit of analysis is file, which is easily separable and trackable with a VCS machinery. Class shares the advantages of file, since numerous software projects obey, either by virtue of conventional guidelines or due to language constraints, the \emph{one class per file} rule. The scope of a class or a file is also usually narrow enough to serve as an object of manual inspection in case of high bug-proneness score.

Using method or function as the unit of analysis is a more complicated task, but it has been also successfully accomplished (e.g. by Giger \textit{et al.} in \cite{method-level}). Contrary to higher-level units described above, which can be identified using solely lists of files, ascribing faults to certain methods requires examining detailed information about code changes. The results of method-level prediction could be considered most useful for debugging due to their fine granularity.

\subsection{Identification of bugs}
\label{sec:identification}
[\textit{In this section I will describe difficulties connected with identifying former bugs.}]

\subsection{Observable variables}
\label{sec:observable_variables}
[\textit{This section will contain a listing of possible features which may be used for the prediction.}]

\section{Related work}
\label{sec:realted_work}
[\textit{This section will present a possibly broad overview of different approaches towards the problem and their concise assessment.}]

\chapter{The proposed approach}
\label{cha:approach}
[\textit{In this chapter I will present my approach to the problem.}]

\section{The model}
\label{sec:model}
[\textit{This section will contain details about the model of changing method which underlies the approach.}]

\section{Feature extraction}
\label{sec:feature_extraction}
[\textit{In this section I will describe in detail all the features of the model}]

\subsection{Fine-grained changes}
\label{sec:fine-grained_changes}
[\textit{In this subsection I will present the idea of fine-grained source code changes identified by ChangeDistiller tool and argue for their usefulness for bug prediction.}]

\subsection{Features}
\label{sec:features}
[\textit{In this subsection I will enumerate all the model's features (based on fine-grained changes described in the previous subsection)}]

\section{Bug-proneness approximation}
\label{sec:bug-proneness}
[\textit{In this section I will present the process of identification of bug-fixing commits and approximating the bug-proneness parameter.}]

\section{Machine learning}
\label{sec:machine_learning}
[\textit{This section will contain brief descriptions of all machine learning algorithms tested during the development of my program.}]

\subsection{Decision tree}
\label{sec:decision_tree}

\subsection{Random forest}
\label{sec:random_forest}

\subsection{Support vector machine}
\label{sec:svm}

\subsection{Neural network}
\label{sec:neural_net}

\chapter{Implementation}
\label{cha:implementation}
[\textit{In this chapter I will provide detailed information about the implementation of the ideas presented in the previous chapter.}]

\section{Languages and tools}
\label{sec:languagess}
[\textit{This section will contain brief description of all used programming languages, tools and libraries along with reasons for choosing this particular ones.}]

\section{Interface}
\label{sec:interface}
[\textit{In this section I will describe functions provided by the implemented tool - ChangeAnalyzer.}]

\section{Architecture}
\label{sec:architecture}
[\textit{In this section I will present the architecture of ChangeAnalyzer.}]

\chapter{Experiments}
\label{cha:experiments}
[\textit{This chapter will contain information about performed experiments which use ChangeAnalyzer and serve as a basis for the evaluation of the proposed approach.}]

\section{Methodology}
\label{sec:methodology}
[\textit{In this section I will describe the experimental methods used.}]

\section{Experimental set-up}
\label{sec:set-up}
[\textit{In this section I will describe the configuration of ChangeAnalyzer used for performing experiments described in the next section.}]

\section{Results}
\label{sec:results}
[\textit{This section will present the results of the experiments in form of tables and charts.}]

\chapter{Conclusions}
\label{cha:conclusions}
[\textit{This chapter will contain the final conclusions of my thesis.}]

\section{Commentary of experimental results}
\label{sec:commentary}
[\textit{In this section I will comment the experimental results.}]

\section{Threats to validity}
\label{sec:threats}
[\textit{In this section I will describe possible threats to the validity of my experiments.}]

\section{Assessment of the approach}
\label{sec:assessment}
[\textit{In this section I will extend the commentary presented in the previous section into a more general judgement of the proposed approach.}]

\section{Possible further work}
\label{sec:further_work}
[\textit{In this section I will outline the possibilities of continuing my work.}]

\printbibliography[heading=bibintoc]

\end{document}